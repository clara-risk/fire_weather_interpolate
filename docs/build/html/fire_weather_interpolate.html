
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>fire_weather_interpolate package &#8212; Fire Weather Interpolate 0.1.1 documentation</title>
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Fire Weather Interpolate 0.1.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">fire_weather_interpolate package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="fire-weather-interpolate-package">
<h1>fire_weather_interpolate package<a class="headerlink" href="#fire-weather-interpolate-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-Eval">
<span id="fire-weather-interpolate-eval-module"></span><h2>fire_weather_interpolate.Eval module<a class="headerlink" href="#module-Eval" title="Permalink to this headline">¶</a></h2>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>Functions to evaluate the outputs of the FWI metrics functions, such as ridge regression for relating the metrics to area burned.</p>
<p class="rubric">References</p>
<p>See:
<a class="reference external" href="https://en.wikipedia.org/wiki/Tikhonov_regularization">https://en.wikipedia.org/wiki/Tikhonov_regularization</a>
<a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RidgeCV.html">https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.RidgeCV.html</a></p>
<dl class="py function">
<dt id="Eval.check_p_value">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">check_p_value</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_excel_spreadsheet</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.check_p_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Quality-control for p-value calculation
:param path_to_excel_spreadsheet: path to the spreadsheet containing the fire season start/end values,</p>
<blockquote>
<div><p>Notes: No trailing 0s in speadsheet, no space after parameter name in header</p>
</div></blockquote>
<dl class="field-list simple">
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.get_MAE">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">get_MAE</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">absolute_error_dictionary</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.get_MAE" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate mean absolute error
:param absolute_error_dictionary: dictionary output from the cross-validation procedure
:type absolute_error_dictionary: dictionary</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>float</em> –</p>
<ul>
<li><p>MAE</p></li>
</ul>
</li>
<li><p><em>float</em> –</p>
<ul>
<li><p>highest absolute error at any of the stations</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.get_RMSE">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">get_RMSE</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">absolute_error_dictionary</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.get_RMSE" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate RMSE
:param absolute_error_dictionary: dictionary output from the cross-validation procedure
:type absolute_error_dictionary: dictionary</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>RMSE value</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.get_interpolated_val_in_fire">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">get_interpolated_val_in_fire</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fire_shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolated_surface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.get_interpolated_val_in_fire" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to get the FWI metric value inside the fire.
We will use to calculate the max FWI metrics for a fire.
:param fire_shapefile: path to the fire shapefile
:type fire_shapefile: string
:param shapefile: path to the study area shapefile
:type shapefile: string
:param latlon_dict: lookup dictionary of lat lon for each station
:type latlon_dict: dictionary
:param interpolated_surface: an array of values in the study area
:type interpolated_surface: ndarray</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>maximum value in fire, either the closest point to the convex hull of the fire or a sum of the points inside the fire</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.get_report_date_plus_three">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">get_report_date_plus_three</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fire_shapefile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.get_report_date_plus_three" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to return the first four days of the fire
:param fire_shapefile: path to the fire shapefile
:type fire_shapefile: string</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><strong>fire_dates</strong> –</p>
<ul class="simple">
<li><p>list of the report date and three days after</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.highest_value_first_four_days">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">highest_value_first_four_days</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fire_shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolated_surface_d1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolated_surface_d2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolated_surface_d3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolated_surface_d4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.highest_value_first_four_days" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to return the highest FWI values in a fire for four input arrays
:param fire_shapefile: path to the fire shapefile
:type fire_shapefile: string
:param shapefile: path to the study area shapefile
:type shapefile: string
:param latlon_dict: lookup dictionary of lat lon for each station
:type latlon_dict: dictionary
:param interpolated_surface_d1: an array of values in the study area, in the first four days of the fire
:type interpolated_surface_d1: ndarray
:param d2: an array of values in the study area, in the first four days of the fire
:type d2: ndarray
:param d3: an array of values in the study area, in the first four days of the fire
:type d3: ndarray
:param d4: an array of values in the study area, in the first four days of the fire
:type d4: ndarray</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><p><strong>max_val</strong> –</p>
<ul class="simple">
<li><p>maximum value for first four days since report date</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.is_it_in_zone">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">is_it_in_zone</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_zones</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Zone1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Zone2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Zone3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Zone4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.is_it_in_zone" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if a fire is inside a zone (ecozone, intensively managed zone, etc.)
:param file_path: path to the location where the fire shapefiles are stored by year
:type file_path: string
:param file_path_zones: path to where the shapefiles for the zones are located
:type file_path_zones: string
:param Zone1-4: names of the zones, Zone1 is required, the rest are optional, takes up to 4</p>
<blockquote>
<div><p>Note: if you are not using the other three zones, input “None”</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>save_path</strong> (<em>string</em>) – path where you want to save the output text file</p>
</dd>
</dl>
<dl class="simple">
<dt>Returns</dt><dd><p>Prints out the fires plus what zone it is in</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.linear_regression">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">linear_regression</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_excel_spreadsheet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_distributions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_residual_histogram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.linear_regression" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a linear regression model and print out the resulting coefficients and (if True) the histogram of residuals
:param path_to_excel_spreadsheet: path to the spreadsheet containing the fire season start/end values,</p>
<blockquote>
<div><p>Notes: No trailing 0s in speadsheet, no space after parameter name in header</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plot_distributions</strong> (<em>bool</em>) – if True, will plot the correlation diagram for all the variables</p></li>
<li><p><strong>plot_residual_histogram</strong> (<em>bool</em>) – if True, will plot a histogram showing the residuals to check if normally distributed</p></li>
<li><p><strong>transform</strong> (<em>bool</em>) – if True, it will transform the input data, to make it normally distributed</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.plot">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">plot</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idw1_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idw2_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idew1_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idew2_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tpss_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rf_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ok_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">varname</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot all the maps for the different spatial interpolation methods on one figure
:param shapefile: path to the study area shapefile
:type shapefile: string</p>
<blockquote>
<div><dl class="simple">
<dt>maxmin<span class="classifier">list</span></dt><dd><p>extent of the image to plot, you can get it from any of the interpolation functions</p>
</dd>
<dt>idw1_grid (etc.)<span class="classifier">ndarray</span></dt><dd><p>the arrays generated for the different spatial interpolation methods</p>
</dd>
<dt>varname<span class="classifier">string</span></dt><dd><p>name of the variable being shown</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt id="Eval.plot_LOOCV_error">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">plot_LOOCV_error</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">error_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.plot_LOOCV_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a map of the LOOCV error (not absolute valued) so we can see the variation in error
accross the study area
:param loc_dict: lookup dictionary for station locations
:type loc_dict: dictionary
:param error_dictionary: a dictionary of the error, produced by the cross-validate function
:type error_dictionary: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param var_name: variable name, for example, Start Day (Days since March 1)
:type var_name: string</p>
</dd></dl>

<dl class="py function">
<dt id="Eval.ridge_regression">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">ridge_regression</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_excel_spreadsheet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_distributions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_residual_histogram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">transform</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.ridge_regression" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a ridge regression model and print out the resulting coefficients and (if True) the histogram of residuals
:param path_to_excel_spreadsheet: path to the spreadsheet containing the FWI values for each fire and the other covariates,</p>
<blockquote>
<div><p>Notes: No trailing 0s in speadsheet, no space after parameter name in header</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var1-10</strong> (<em>string</em>) – variable names, corresponding to the header names</p></li>
<li><p><strong>all_variables</strong> (<em>bool</em>) – if True, will use all the variables, not just the FWI metrics</p></li>
<li><p><strong>plot_distributions</strong> (<em>bool</em>) – if True, will plot the correlation diagram for all the variables</p></li>
<li><p><strong>plot_residual_histogram</strong> (<em>bool</em>) – if True, will plot a histogram showing the residuals to check if normally distributed</p></li>
<li><p><strong>transform</strong> (<em>bool</em>) – if True, it will transform the input data (i.e. the fire surface area),
to make it normally distributed</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.ridge_regression_stratify">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">ridge_regression_stratify</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path_to_excel_spreadsheet</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_distributions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_residual_histogram</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stratify_condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ecozone_condition</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.ridge_regression_stratify" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a ridge regression model stratified based on different ecozones and fire characteristics
and print out the resulting coefficients and (if True) the histogram of residuals
:param path_to_excel_spreadsheet: path to the spreadsheet containing the FWI values for each fire and the other covariates,</p>
<blockquote>
<div><p>Notes: No trailing 0s in speadsheet, no space after parameter name in header</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var1-10</strong> (<em>string</em>) – variable names, corresponding to the header titles</p></li>
<li><p><strong>all_variables</strong> (<em>bool</em>) – if True, will use all the variables, not just the FWI metrics</p></li>
<li><p><strong>plot_distributions</strong> (<em>bool</em>) – if True, will plot the correlation diagram for all the variables</p></li>
<li><p><strong>plot_residual_histogram</strong> (<em>bool</em>) – if True, will plot a histogram showing the residuals to check if normally distributed</p></li>
<li><p><strong>stratify_condition</strong> (<em>string</em>) – can be one of ‘human’, ‘lightning’, ‘60conifer’, ‘60conifer &amp; lightning’,’none’</p></li>
<li><p><strong>size_condition</strong> (<em>string</em>) – can be one of ‘all’, ‘&lt;200’, ‘&gt;=200’</p></li>
<li><p><strong>ecozone_condition</strong> (<em>string</em>) – can be one of ‘none’,’taiga’,’boreal1’ (west), ‘boreal2’ (east), ‘hudson’</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.select_random_station">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">select_random_station</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">groups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocknum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">used_stations</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.select_random_station" title="Permalink to this definition">¶</a></dt>
<dd><p>Select a random station from each group for bagging xval
:param groups: dictionary of what group each station belongs to
:type groups: dictionary
:param blocknum: number of blocks
:type blocknum: int
:param replacement: whether or not to use replacement
:type replacement: bool
:param used_stations: empty list if using replacement, if not, it is a list of already used stations
:type used_stations: list</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>dictionary of selected stations</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.stratify_dataset">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">stratify_dataset</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stratify_condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.stratify_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a sub-function that will be called to stratify the fires based on different
characteristics in the ridge regression (stratify) function.
:param df: dataframe of the spreadsheet containing the information for each fire
:type df: pandas dataframe
:param stratify_condition: characteristics of fire/fire location you want to preserve in the dataset,</p>
<blockquote>
<div><p>one of: “none”, “human”,”lightning”,”60conifer”,”60conifer &amp; lightning”</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_condition</strong> (<em>string</em>) – size condition you want to use to stratify (select specific rows), either “all”, “&lt;200”,”&gt;=200”</p></li>
<li><p><strong>all_variables</strong> (<em>bool</em>) – if True, create an array with all the variables (not just FWI metrics) for regression</p></li>
<li><p><strong>var1-10</strong> (<em>string</em>) – variable names, corresponding to the header names</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>ndarray</em> –</p>
<ul>
<li><p>array of predictor variables, for input to the regression</p></li>
</ul>
</li>
<li><p><em>ndarray</em> –</p>
<ul>
<li><p>array of response variables, for input to the regression</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="Eval.stratify_size">
<code class="sig-prename descclassname"><span class="pre">Eval.</span></code><code class="sig-name descname"><span class="pre">stratify_size</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_condition</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_variables</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#Eval.stratify_size" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a sub-function that will be called to stratify the fires based on size in the
ridge regression (stratify) function.
:param df: dataframe of the spreadsheet containing the information for each fire
:type df: pandas dataframe
:param size_condition: size condition you want to use to stratify (select specific rows), either “all”, “&lt;200”,”&gt;=200”
:type size_condition: string
:param all_variables: if True, create an array with all the variables (not just FWI metrics) for regression
:type all_variables: bool
:param var1-10: variable names, corresponding to the header names
:type var1-10: string</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>ndarray</em> –</p>
<ul>
<li><p>array of predictor variables, for input to the regression</p></li>
</ul>
</li>
<li><p><em>ndarray</em> –</p>
<ul>
<li><p>array of response variables, for input to the regression</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-auto_select">
<span id="fire-weather-interpolate-auto-select-module"></span><h2>fire_weather_interpolate.auto_select module<a class="headerlink" href="#module-auto_select" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id1">
<h3>Summary<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>Auto-selection protocol for spatial interpolation methods using shuffle-split cross-validation.
.. rubric:: References</p>
<dl class="py function">
<dt id="auto_select.execute_sequential_calc">
<code class="sig-prename descclassname"><span class="pre">auto_select.</span></code><code class="sig-name descname"><span class="pre">execute_sequential_calc</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path_hourly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_daily_csv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dictionary_hourly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dictionary_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'pcp':</span> <span class="pre">['316**2</span> <span class="pre">*</span> <span class="pre">Matern(length_scale=[5e+05,</span> <span class="pre">5e+05,</span> <span class="pre">4.67e+05],</span> <span class="pre">nu=0.5)'],</span> <span class="pre">'rh':</span> <span class="pre">['307**2</span> <span class="pre">*</span> <span class="pre">Matern(length_scale=[5e+05,</span> <span class="pre">6.62e+04,</span> <span class="pre">1.07e+04],</span> <span class="pre">nu=0.5)'],</span> <span class="pre">'temp':</span> <span class="pre">['316**2</span> <span class="pre">*</span> <span class="pre">Matern(length_scale=[5e+05,</span> <span class="pre">5e+05,</span> <span class="pre">6.01e+03],</span> <span class="pre">nu=0.5)'],</span> <span class="pre">'wind':</span> <span class="pre">['316**2</span> <span class="pre">*</span> <span class="pre">Matern(length_scale=[5e+05,</span> <span class="pre">6.62e+04,</span> <span class="pre">1.07e+04],</span> <span class="pre">nu=0.5)']}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#auto_select.execute_sequential_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the DC, DMC, FFMC seq calculations
:param file_path_hourly: path to hourly feather files
:type file_path_hourly: string
:param file_path_daily: path to daily feather files
:type file_path_daily: string
:param file_path_daily_csv: path to daily csv files
:type file_path_daily_csv: string
:param var_name: name of weather variable you are interpolating
:type var_name: string
:param input_date: date of weather data (day of fire season)
:type input_date: string
:param loc_dictionary_daily: dictionary of station locations (daily)
:type loc_dictionary_daily: dictionary
:param loc_dictionary_hourly: dictionary of station locations (hourly)
:type loc_dictionary_hourly: dictionary
:param year: year to execute sequential calculations for
:type year: string
:param interpolation_types: list of interpolation types to consider
:type interpolation_types: list
:param rep: number of replications to run
:type rep: int
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param save_path: where in computer to save the output file to
:type save_path: string
:param shapefile: path to study area shapefile (ON + QC)
:type shapefile: string
:param shapefile2: path to boreal shapefile
:type shapefile2: string
:param phi_input: smoothing parameter for the thin plate spline, if 0 no smoothing, default is None (it is calculated)
:type phi_input: float
:param calc_phi: whether to calculate phi in the function, if True, phi can = None
:type calc_phi: bool
:param kernels: the kernels for each weather variable for gaussian process regression
:type kernels: dictionary</p>
<dl class="simple">
<dt>Returns</dt><dd><dl class="simple">
<dt>list</dt><dd><ul class="simple">
<li><p>list of array of FWI codes for each day in fire season</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="auto_select.run_comparison">
<code class="sig-prename descclassname"><span class="pre">auto_select.</span></code><code class="sig-name descname"><span class="pre">run_comparison</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation_types</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cvar_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'pcp':</span> <span class="pre">['316**2</span> <span class="pre">*</span> <span class="pre">Matern(length_scale=[5e+05,</span> <span class="pre">5e+05,</span> <span class="pre">4.67e+05],</span> <span class="pre">nu=0.5)'],</span> <span class="pre">'rh':</span> <span class="pre">['307**2</span> <span class="pre">*</span> <span class="pre">Matern(length_scale=[5e+05,</span> <span class="pre">6.62e+04,</span> <span class="pre">1.07e+04],</span> <span class="pre">nu=0.5)'],</span> <span class="pre">'temp':</span> <span class="pre">['316**2</span> <span class="pre">*</span> <span class="pre">Matern(length_scale=[5e+05,</span> <span class="pre">5e+05,</span> <span class="pre">6.01e+03],</span> <span class="pre">nu=0.5)'],</span> <span class="pre">'wind':</span> <span class="pre">['316**2</span> <span class="pre">*</span> <span class="pre">Matern(length_scale=[5e+05,</span> <span class="pre">6.62e+04,</span> <span class="pre">1.07e+04],</span> <span class="pre">nu=0.5)']}</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#auto_select.run_comparison" title="Permalink to this definition">¶</a></dt>
<dd><p>Execute the shuffle-split cross-validation for the given interpolation types
:param var_name: name of weather variable you are interpolating
:type var_name: string
:param input_date: date of weather data (day of fire season)
:type input_date: string
:param interpolation_types: list of interpolation types to consider
:type interpolation_types: list
:param rep: number of replications to run
:type rep: int
:param loc_dictionary: dictionary of station locations
:type loc_dictionary: dictionary
:param cvar_dictionary: dictionary containing the weather data for each station available
:type cvar_dictionary: dictionary
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param elev_array: array for elevation, create using IDEW interpolation (this is a trick to speed up code)
:type elev_array: ndarray
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param phi_input: smoothing parameter for the thin plate spline, if 0 no smoothing, default is None (it is calculated)
:type phi_input: float
:param calc_phi: whether to calculate phi in the function, if True, phi can = None
:type calc_phi: bool
:param kernels: the kernels for each weather variable for gaussian process regression
:type kernels: dictionary</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>returns the selected interpolation type name</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>string</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-cluster_3d">
<span id="fire-weather-interpolate-cluster-3d-module"></span><h2>fire_weather_interpolate.cluster_3d module<a class="headerlink" href="#module-cluster_3d" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id2">
<h3>Summary<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>Code for making spatial clusters for cross-validation.</p>
<dl class="py function">
<dt id="cluster_3d.spatial_cluster">
<code class="sig-prename descclassname"><span class="pre">cluster_3d.</span></code><code class="sig-name descname"><span class="pre">spatial_cluster</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_2D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_3D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_all</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cluster_3d.spatial_cluster" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatial clustering based on scikit learn’s agglomerative clustering
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param clusternum: number of clusters
:type clusternum: int
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param plot_2D: whether to plot maps of the clusters in 2d
:type plot_2D: bool
:param plot_3D: whether to plot maps of the clusters in 3d
:type plot_3D: bool
:param return_all: whether or not to return all the outputs (needed for selecting cluster size)
:type return_all: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>a dictionary of cluster that each station is in</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-fwi">
<span id="fire-weather-interpolate-fwi-module"></span><h2>fire_weather_interpolate.fwi module<a class="headerlink" href="#module-fwi" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>Summary<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>Code for calculating the FWI metrics.</p>
<p class="rubric">References</p>
<p>Wang, X., Wotton, B. M., Cantin, A. S., Parisien, M. A., Anderson, K., Moore,
B., &amp; Flannigan, M. D. (2017). cffdrs: an R package for the Canadian Forest
Fire Danger Rating System. Ecological Processes, 6(1). <a class="reference external" href="https://doi.org/10.1186/s13717-017-0070-z">https://doi.org/10.1186/s13717-017-0070-z</a></p>
<p>Wotton, B. M. (2009). Interpreting and using outputs from the Canadian Forest
Fire Danger Rating System in research applications. Environmental and Ecological
Statistics, 16(2), 107–131. <a class="reference external" href="https://doi.org/10.1007/s10651-007-0084-2">https://doi.org/10.1007/s10651-007-0084-2</a></p>
<p>Code is translated from R package:
<a class="reference external" href="https://github.com/cran/cffdrs/tree/master/R">https://github.com/cran/cffdrs/tree/master/R</a></p>
<dl class="py function">
<dt id="fwi.BUI">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">BUI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dmc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endMask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.BUI" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate BUI
Parameters</p>
<blockquote>
<div><p>dmc (np_array): the dmc array for the date of interest
dc (np_array): the dc array for the date of interest
maxmin (list): bounds of the study area
show (bool): whether or not to display the map
shapefile (str): path to the study area shapefile
mask (np_array): mask for the start up date
endMask (np_array): mask for the shut down date</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>bui1 (np_array): array containing BUI values for the study area</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.DC">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">DC</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rain_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rh_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wind_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc_yesterday</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endMask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_DC_val_before_shutdown</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwinter</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.DC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the DC. See cffdrs R code
Parameters</p>
<blockquote>
<div><p>input_date (str): input date of interest
rain_grid: interpolated surface for rainfall on the date of interest
temp_grid: interpolated surface for temperature on the date of interest
wind_grid: interpolated surface for wind on the date of interest
maxmin: bounds of the study area
dc_yesterday: array of DC values for yesterday (from the dc stack list/if this function
is being used inside dc_stack it is calculated then)
index (int): index of the date since Mar 1
show (bool): whether you want to show the map
shapefile (str): path to the study area shapefile
mask (np_array): mask for the start dates
endMask (np_array): mask for the end days
last_DC_val_before_shutdown (np_array): array for last dc values before cell shut down, if no areas
required the procedure, you can input an empty array of the correct size (if not using overwinter, input
the empty array)
overwinter (bool): whether or not to implement the overwinter procedure</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>dc1 (np_array): array of dc values on the date on interest for the study area</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.DMC">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">DMC</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rain_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rh_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wind_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dmc_yesterday</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endMask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.DMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the DMC. See cffdrs R code
Parameters</p>
<blockquote>
<div><p>input_date (str): input date of interest
rain_grid: interpolated surface for rainfall on the date of interest
rh_grid: interpolated surface for relative humidity on the date of interest
temp_grid: interpolated surface for temperature on the date of interest
wind_grid: interpolated surface for wind on the date of interest
maxmin: bounds of the study area
dmc_yesterday: array of DMC values for yesterday (from the dmc stack list/if this function
is being used inside dmc_stack it is calculated then)
index (int): index of the date since Mar 1
show (bool): whether you want to show the map
shapefile (str): path to the study area shapefile
mask (np_array): mask for the start dates
endMask (np_array): mask for the end days</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>dmc (np_array): array of dmc values on the date on interest for the study area</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.FFMC">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">FFMC</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rain_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rh_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">temp_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wind_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ffmc_yesterday</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endMask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.FFMC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the FFMC. See cffdrs R code
Parameters</p>
<blockquote>
<div><p>input_date (str): input date of interest
rain_grid: interpolated surface for rainfall on the date of interest
rh_grid: interpolated surface for relative humidity on the date of interest
temp_grid: interpolated surface for temperature on the date of interest
wind_grid: interpolated surface for wind on the date of interest
maxmin: bounds of the study area
ffmc_yesterday: array of FFMC values for yesterday (from the ffmc stack list/if this function
is being used inside ffmc_stack it is calculated then)
index (int): index of the date since Mar 1
show (bool): whether you want to show the map
shapefile (str): path to the study area shapefile
mask (np_array): mask for the start dates
endMask (np_array): mask for the end days</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>ffmc1 (np_array): array of ffmc values on the date on interest for the study area</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.FWI">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">FWI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bui</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endMask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.FWI" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate FWI
Parameters</p>
<blockquote>
<div><p>isi (np_array): calculated isi surface for the date of interest
bui (np_array): calculated bui surface for the date of interest
maxmin (list): bounds of the study area
show (bool): whether or not to show the map
shapefile (str): path to the shapefile
mask (np_array): start up mask
endMask (np_array): shut down mask</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>fwi (np_array): calculated FWI surface for the study area</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.ISI">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">ISI</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ffmc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wind_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endMask</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.ISI" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate ISI
Parameters</p>
<blockquote>
<div><p>ffmc (np_array): ffmc array for the date of interest
wind_grid (np_array): wind speed interpolated array for the date of interest
maxmin (list): bounds of the shapefile
show (bool): whether or not to display the map
shapefile (str): path to the study area shapefile
mask (np_array): mask for the start up date
endMask (np_array): mask for the shutdown date</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>isi (np_array): the calculated array for ISI for the study area</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.calc_duration_in_ecozone">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">calc_duration_in_ecozone</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_hourly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list_of_ecozone_names</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_hourly_stns</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.calc_duration_in_ecozone" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculation the yearly duration between years 1-2 and output to dictionary for graphing
Parameters</p>
<blockquote>
<div><p>file_path_daily (str): path to the daily files
file_path_hourly (str): path to the files containing the hourly data from Environment &amp;
Climate Change Canada
file_path_elev (str): path to the elevation lookup file
idx_list (list): the index of the elevation data column in the lookup file
shapefile (str): path to the shapefile of the study area
list_of_ecozone_names (list of str): list of ecozone names you want to calculate duration for, ex [‘taiga’,’hudson’],
must correspond to the names of the shapefiles in the folder ecozone_shp in the working directory
year1 (int,str): start year
year2 (int,str): end year
method (str): spatial model, one of: IDW2,IDW3,IDW4,TPSS,RF
expand_area (bool): whether or not to expand area by 200km
add_hourly_stns (bool): whether or not to add in hourly stations after 1994</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>duration_dict (dict): dictionary keyed by year then ecozone that contains a list of durations from year1-year2 (year2 inclusive)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.calc_season_change">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">calc_season_change</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">earlier_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">later_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.calc_season_change" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the change between seasons so we can evaluate how much the season has changed over time.
Parameters</p>
<blockquote>
<div><p>earlier_array (np_array): array of fire season duration values for the earlier year, ex 1919
later_array (np_array): array of fire season duration values for the later year, ex 2019</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>change_array (np_array): array containing the difference for each pixel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.dc_overwinter_procedure">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">dc_overwinter_procedure</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">last_DC_val_before_shutdown_masked_reshape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwinter_pcp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.dc_overwinter_procedure" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the overwinter procedure, see Wang et al. (2017) for more details
Parameters</p>
<blockquote>
<div><p>last_DC_val_before_shutdown_masked_reshape (np_array): output of get_last_dc_before_shutdown, array containing the last
dc value before the station shut down interpolated across the study area
overwinter_pcp (np_array): overwinter precipitation amount in each cell
b_list (list, loaded from json): list containing information for the b parameter, can be formatted into an array</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>DCs (np_array): the new values for the start-up DC procedure, to be used in areas identified as needing the overwinter
procedure</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.dc_stack">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">dc_stack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_hourly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">day_interpolated_surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_interpolated_surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">last_DC_val_before_shutdown</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwinter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latlon_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">json</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation_method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.dc_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Calc dc for each day in season. This is the only metric with overwinter procedure applied.
For notes see cffdrs R code.
Parameters</p>
<blockquote>
<div><p>dates (list): list of all dates within the fire season, inactive stations will be masked out
so you can define it as Mar 1 - Dec 31
file_path_daily (str): file path to the daily feather files
file_path_hourly (str): file path to the hourly feather files
var_name (str): name of the variable you are interpolating
shapefile (str): path to the study area shapefile
day_interpolated_surface (np_array): array of start-up days (since Mar 1) for the study area
end_interpolated_surface (np_array): array of end days (since Oct 1) for the study area
last_DC_val_before_shutdown (np_array): the last DC value in each cell before that cell shut down
for the winter (WITH THE OVERWINTER PROCEDURE APPLIED); only need to input this if overwinter
= True otherwise you can just input None
overwinter (bool): if True, the program overwinters the DC where it needs to be
file_path_elev (str): file path to the elevation lookup file
idx_list (list): the index of the elevation data column in the lookup file
date_dictionary (dict, loaded from .json): lookup file that has what day/month pairs each
station contains data for
latlon_dict (dict, loaded from .json): lat lons of the hourly stations
latlon_dictionary (dict, loaded from .json): lat lons of the daily stations
json (bool): if True, convert the array to a flat list so it can be written as a .json file
interpolation_method (str): the interpolation method to use to get the continuous DC surface,
there are eight options - IDW-1, IDW-2, IDEW-1, IDEW-2, TPS, TPSS, OK, RF</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>dc_list (list of np_array): a list of the interpolated surfaces for the drought code for
each day in the fire season</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.dmc_stack">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">dmc_stack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_hourly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">day_interpolated_surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_interpolated_surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latlon_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">json</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation_method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.dmc_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Calc dmc for each day in fire season. For notes see cffdrs R code.
Parameters</p>
<blockquote>
<div><p>dates (list): list of all dates within the fire season, inactive stations will be masked out
so you can define it as Mar 1 - Dec 31
file_path_daily (str): file path to the daily feather files
file_path_hourly (str): file path to the hourly feather files
var_name (str): name of the variable you are interpolating
shapefile (str): path to the study area shapefile
day_interpolated_surface (np_array): array of start-up days (since Mar 1) for the study area
end_interpolated_surface (np_array): array of end days (since Oct 1) for the study area
file_path_elev (str): file path to the elevation lookup file
idx_list (list): the index of the elevation data column in the lookup file
date_dictionary (dict, loaded from .json): lookup file that has what day/month pairs each
station contains data for
latlon_dict (dict, loaded from .json): lat lons of the hourly stations
latlon_dictionary (dict, loaded from .json): lat lons of the daily stations
json (bool): if True, convert the array to a flat list so it can be written as a .json file
interpolation_method (str): the interpolation method to use to get the continuous DMC surface,
there are eight options - IDW-1, IDW-2, IDEW-1, IDEW-2, TPS, TPSS, OK, RF</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>dmc_list (list of np_array): a list of the interpolated surfaces for the duff moisture code for
each day in the fire season</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.end_date_add_hourly">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">end_date_add_hourly</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path_hourly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.end_date_add_hourly" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of where each station meets the end criteria,
plus a reference dictionary for the lat lon of the stations
Parameters</p>
<blockquote>
<div><p>file_path (str): path to the feather files containing the hourly data from Environment &amp;
Climate Change Canada
year (str): year we want to find the fire season end date for</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>date_dict (dict): dictionary containing the end date for each station (days since Oct 1)
latlon_dictionary (dict): the latitude and longitude of those stations</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.end_date_add_hourly_csv">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">end_date_add_hourly_csv</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path_hourly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.end_date_add_hourly_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of where each station meets the end criteria,
plus a reference dictionary for the lat lon of the stations
Parameters</p>
<blockquote>
<div><p>file_path (str): path to the feather files containing the hourly data from Environment &amp;
Climate Change Canada
year (str): year we want to find the fire season end date for</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>date_dict (dict): dictionary containing the end date for each station (days since Oct 1)
latlon_dictionary (dict): the latitude and longitude of those stations</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.end_date_calendar">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">end_date_calendar</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.end_date_calendar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of where each station meets the start up criteria,
plus a reference dictionary for the lat lon of the stations
Parameters</p>
<blockquote>
<div><p>file_path (str): path to the feather files containing the hourly data from Environment &amp;
Climate Change Canada
year (str): year we want to find the fire season end date for</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>date_dict (dict): dictionary containing the end date for each station (days since Oct 1)
latlon_dictionary (dict): the latitude and longitude of those stations</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.end_date_calendar_csv">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">end_date_calendar_csv</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_month</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.end_date_calendar_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of where each station meets the end criteria see
Wotton &amp; Flannigan 1993, plus a reference dictionary for the lat lon of the stations
Parameters</p>
<blockquote>
<div><p>file_path (str): path to the csv files containing the hourly data from Environment &amp;
Climate Change Canada
year (str): year we want to find the fire season end date for
search_month (str): the month (day 1) you want to start searching for the end date, enter ‘sep’ or ‘oct’</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>date_dict (dict): dictionary containing the end date for each station (days since Oct 1)
latlon_dictionary (dict): the latitude and longitude of those stations</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.extract_fire_season_frm_NFDB">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">extract_fire_season_frm_NFDB</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ecozone_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_date_end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_date_start</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.extract_fire_season_frm_NFDB" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first and last lightning-caused ignitions from the database in ecozone
Parameters</p>
<blockquote>
<div><p>file_path (str): path to ignition lookup file
year1 (int): start year
year2 (int): end year
ecozone_path (str): path to the ecozone shapefile
out_path (str): where to save the results file
search_date_end (str): ‘oct’ or ‘sep’, when to start looking for the last date
search_date_start (str): ‘feb’ or ‘mar’, when to start looking for the last date,
january start dates considered unrealistic…</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>first_date (str): first lightning caused ignition in ecozone
last_date (str): last lightning caused ignition in ecozone</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.extract_fire_season_frm_fire_archive_report">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">extract_fire_season_frm_fire_archive_report</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ecozone_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_date_end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">search_date_start</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.extract_fire_season_frm_fire_archive_report" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first and last lightning-caused ignitions from the extra dataset
Parameters</p>
<blockquote>
<div><p>file_path (str): path to ignition lookup file
year1 (int): start year
year2 (int): end year
ecozone_path (str): path to the ecozone shapefile
out_path (str): where to save the results file
search_date_end (str): ‘oct’ or ‘sep’, when to start looking for the last date
search_date_start (str): ‘feb’ or ‘mar’, when to start looking for the last date,
january start dates considered unrealistic…</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>first_date (str): first lightning caused ignition in ecozone
last_date (str): last lightning caused ignition in ecozone
writes output to csv file</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.ffmc_stack">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">ffmc_stack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_hourly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">day_interpolated_surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_interpolated_surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latlon_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">json</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation_method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.ffmc_stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Calc ffmc for each day in season. For notes see cffdrs R code.
Parameters</p>
<blockquote>
<div><p>dates (list): list of all dates within the fire season, inactive stations will be masked out
so you can define it as Mar 1 - Dec 31
file_path_daily (str): file path to the daily feather files
file_path_hourly (str): file path to the hourly feather files
var_name (str): name of the variable you are interpolating
shapefile (str): path to the study area shapefile
day_interpolated_surface (np_array): array of start-up days (since Mar 1) for the study area
end_interpolated_surface (np_array): array of end days (since Oct 1) for the study area
file_path_elev (str): file path to the elevation lookup file
idx_list (list): the index of the elevation data column in the lookup file
date_dictionary (dict, loaded from .json): lookup file that has what day/month pairs each
station contains data for
latlon_dict (dict, loaded from .json): lat lons of the hourly stations
latlon_dictionary (dict, loaded from .json): lat lons of the daily stations
json (bool): if True, convert the array to a flat list so it can be written as a .json file
interpolation_method (str): the interpolation method to use to get the continuous DMC surface,
there are eight options - IDW-1, IDW-2, IDEW-1, IDEW-2, TPS, TPSS, OK, RF</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>ffmc_list (list of np_array): a list of the interpolated surfaces for the fine fuel moisture code for
each day in the fire season</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.get_date_index">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">get_date_index</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">month</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.get_date_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of days for the date of interest from the first of the month of interest
Example, convert to days since March 1
Parameters</p>
<blockquote>
<div><p>year (str): year of interest
input_date (str): input date of interest
month (str): the month from when you want to calculate the date (ex, Mar 1)</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>day (int): days since 1st of the month of interest</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.get_last_dc_before_shutdown">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">get_last_dc_before_shutdown</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dc_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">endsurface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwinter_reqd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.get_last_dc_before_shutdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an array of the last dc vals before station shutdown for winter for the study area
Parameters</p>
<blockquote>
<div><p>dc_list (list of np_array): a list of the interpolated surfaces for the drought code for
each day in the fire season
endsurface (np_array): array for end dates for the year before the year of interest
overwinter_reqd (np_array): where the overwinter procedure is required
show (bool): whether you want to plot the map
maxmin (list): bounds of the study area</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>last_DC_val_before_shutdown_masked_reshape (np_array): array of dc values before shutdown for
cells requiring overwinter procedure</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.get_overwinter_pcp">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">get_overwinter_pcp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">overwinter_dates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">latlon_dictionary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">json</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.get_overwinter_pcp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the total amount of overwinter pcp for the purpose of knowing where to use the
overwinter DC procedure
Parameters</p>
<blockquote>
<div><p>overwinter_dates (list): list of dates that are in the winter (i.e. station shut down to
start up), you can just input generally Oct 1-June 1 and stations that are still active
will be masked out
file_path_daily (str): file path to the daily feather files containing the precipitation data
start_surface (np_array): array containing the interpolated start-up date for each cell
end_surface (np_array): array containing the interpolated end date for each cell, from the
year before
maxmin (list): bounds of the study area
shapefile (str): path to the study area shapefile
date_dictionary (dict, loaded from .json): lookup file that has what day/month pairs each
station contains data for
latlon_dictionary (dict, loaded from .json): lat lons of the daily stations
file_path_elev (str): file path to the elevation lookup file
idx_list (list): the index of the elevation data column in the lookup file
json (bool): if True, convert the array to a flat list so it can be written as a .json file
to the hard drive</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>pcp_overwinter (np_array): array of interpolated overwinter precipitation for the study area
overwinter_reqd (np_array): array indicating where to do the overwinter DC procedure</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.make_end_date_mask">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">make_end_date_mask</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">day_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">day_interpolated_surface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.make_end_date_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn the interpolated surface of end dates into a numpy array
Parameters</p>
<blockquote>
<div><p>day_index (int): index of the day of interest since Oct 1
day_interpolated_surface (np_array): the interpolated surface of the end dates across the
study area</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>new (np_array): a mask array of the end date, either activated (1) or inactivated (np.nan)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.make_start_date_mask">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">make_start_date_mask</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">day_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">day_interpolated_surface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.make_start_date_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn the interpolated surface of start dates into a numpy array
Parameters</p>
<blockquote>
<div><p>day_index (int): index of the day of interest since Mar 1
day_interpolated_surface (np_array): the interpolated surface of the start dates across the
study area</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>new (np_array): a mask array of the start date, either activated (1) or inactivated (np.nan)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.plot_all">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">plot_all</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwi_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.plot_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize all values for all in list. <strong>DO NOT HAVE TO CHANGE INDEX IF LEAP YEAR</strong> WHY? B/C WE ARE COUNTING FRM MAR1
Parameters</p>
<blockquote>
<div><p>fwi_list (list): list of fwi metric arrays for a certain measure (i.e. dmc)
maxmin (list): bounds of study area
year (str): year of interest
var (str): variable name of interest (i.e. “Duff Moisture Code”)
shapefile (str): path to study area shapefile
shapefile2 (str): path to masking shapefile</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>plots a figure with fwi metric map for each day</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.plot_july">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">plot_july</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwi_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.plot_july" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize all values for July. <strong>DO NOT HAVE TO CHANGE INDEX IF LEAP YEAR</strong> WHY? B/C WE ARE COUNTING FRM MAR1
Parameters</p>
<blockquote>
<div><p>fwi_list (list): list of fwi metric arrays for a certain measure (i.e. dmc)
maxmin (list): bounds of study area
year (str): year of interest
var (str): variable name of interest (i.e. “Duff Moisture Code”)
shapefile (str): path to study area shapefile
shapefile2 (str): path to masking shapefile</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>plots a figure with fwi metric map for each day in month of July</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.plot_june">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">plot_june</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fwi_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxmin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.plot_june" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize all values for June. <strong>DO NOT HAVE TO CHANGE INDEX IF LEAP YEAR</strong> WHY? B/C WE ARE COUNTING FRM MAR1
Parameters</p>
<blockquote>
<div><p>fwi_list (list): list of fwi metric arrays for a certain measure (i.e. dmc)
maxmin (list): bounds of study area
year (str): year of interest
var (str): variable name of interest (i.e. “Duff Moisture Code”)
shapefile (str): path to study area shapefile
shapefile2 (str): path to masking shapefile</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>plots a figure with fwi metric map for each day in month of June</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.select_and_output_earliest_year">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">select_and_output_earliest_year</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.select_and_output_earliest_year" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the first and last lightning-caused ignitions from the two sources using the csv files
(we are basically combining them)
Parameters</p>
<blockquote>
<div><p>file_path1 (str): path to the output csv file from national fire database
file_path2 (str): path to the output csv file from the extra dataset
year1 (int): start year
year2 (int): end year
out_path (str): where to save the results file</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>first_date (str): first lightning caused ignition in ecozone
last_date (str): last lightning caused ignition in ecozone
writes output to csv file</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.start_date_add_hourly">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">start_date_add_hourly</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path_hourly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.start_date_add_hourly" title="Permalink to this definition">¶</a></dt>
<dd><p>There are not enough daily stations for accurate calculation of the fire season duration in years after about 1996(?) so we need to add in some of the hourly ones.
This is computationally more intensive so should only be used if necessary (ie not for years that already have enough daily stations).
Parameters</p>
<blockquote>
<div><p>file_path_hourly (str): path to the hourly feather files
year (str): str of the year of interest</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>date_dict (dict): start up date dictionary
latlon_dictionary (dict): dictionary of the station locations</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.start_date_calendar">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">start_date_calendar</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.start_date_calendar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of where each station meets the start up criteria, plus a reference dictionary for the lat lon of the stations
Parameters</p>
<blockquote>
<div><p>file_path (str): path to the feather files containing the hourly data from Environment &amp;
Climate Change Canada
year (str): year we want to find the fire season start up date for</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>date_dict (dict): dictionary containing the start up date for each station (days since Mar 1)
latlon_dictionary (dict): the latitude and longitude of those stations</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="fwi.start_date_calendar_csv">
<code class="sig-prename descclassname"><span class="pre">fwi.</span></code><code class="sig-name descname"><span class="pre">start_date_calendar_csv</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fwi.start_date_calendar_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary of where each station meets the start up criteria, plus a reference dictionary for the lat lon of the stations
Parameters</p>
<blockquote>
<div><p>file_path_daily (str): path to the csv files containing the hourly data from Environment &amp;
Climate Change Canada
year (str): year we want to find the fire season start up date for</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>date_dict (dict): dictionary containing the start up date for each station (days since Mar 1)
latlon_dictionary (dict): the latitude and longitude of those stations</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-get_data">
<span id="fire-weather-interpolate-get-data-module"></span><h2>fire_weather_interpolate.get_data module<a class="headerlink" href="#module-get_data" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id4">
<h3>Summary<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>The functions in this file are used for extracting data from the weather data files
downloaded from Environment &amp; Climate Change Canada and terrain lookup files (ex,
slope, drainage).</p>
<p class="rubric">References</p>
<p>get_b relies on information from Lawson &amp; Armitage (2008)</p>
<dl class="py function">
<dt id="get_data.calc_season_duration">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">calc_season_duration</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_surface</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.calc_season_duration" title="Permalink to this definition">¶</a></dt>
<dd><p>For fire season, once we have created the continuous surfaces, we need to calculate for
each pixel what is the estimated duration (for the year).
Parameters</p>
<blockquote>
<div><p>start_surface (np_array): the array of the start dates generated from a function such as IDW()
end_surface (np_array): the array of the end dates
<a href="#id5"><span class="problematic" id="id6">*</span></a>these need to be the same size and should automatically be
year (int): the year that we are calculating the duration for, mostly needed to account for
a leap year</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>season_duration (np_array): an array of the study area for the estimated fire season in the array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.combine_stations">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">combine_stations</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dictionary_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dictionary_hourly</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.combine_stations" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine dictionaries with station names as keys.For example, hourly stations
&amp; daily stations for the fire season calculations.</p>
</dd></dl>

<dl class="py function">
<dt id="get_data.convert_to_feather">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">convert_to_feather</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.convert_to_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the Environment &amp; Climate Change Canada csv files into feather files, to allow for faster processing
Parameters</p>
<blockquote>
<div><p>file_path (str): file path to the csv files provided by Environment &amp; Climate Change
Canada, not including the name of the file
out_path (str): where you want the new feather file to be written to in the computer, not including the new file name</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>The function writes a feather file to the output directory</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.finding_data_frm_lookup">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">finding_data_frm_lookup</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">projected_coordinates_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.finding_data_frm_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dictionary of values for each input point frm lookup file
Parameters</p>
<blockquote>
<div><p>projected_coordinates_list (list of tuples): list of coordinates that you want to find data
in the lookup file for, must be in lon, lat format
file_path (str): file path to the lookup file, includes the file name and ending
idx_list (list): output of get_col_name_list, we will just take the first entry</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>min_distance_L (dict): a dictionary of values for each coordinate (taken from the closest
point in the lookup file to the input coordinate)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_average_in_ecozone">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_average_in_ecozone</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">boolean_ecozone</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous_surface</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_average_in_ecozone" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a function to get the average of the array cells with centroids that are within an ecozone
Parameters</p>
<blockquote>
<div><p>boolean_ecozone (np_array): a boolean array delineating the raster cells belonging to the ecozone
continuous_surface (np_array): an array of values for the study area</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>average_value (float): the average if the array values that fall inside the ecozone</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_b">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_b</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_slope</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_slope</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_drainage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_drainage</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_b" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a permanent lookup file for b for study area for future processing
This is used in overwinter dc procedure
Parameters</p>
<blockquote>
<div><p>latlon_dict (dictionary, to be loaded from json file): dictionary of latitude and longitudes
for the hourly stations
file_path_slope (str): path to the slope file, includes file name
idx_slope (list): index of the slope variable in the header of the slope lookup file
file_path_drainage (str): path to the drainage file, includes file name
idx_drainage (list): index of the drainage variable in the header of the drainage lookup file
shapefile (str): path to the shapefile of the study area (.shp format)</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>The function will write a .json file to the hard drive, which can be loaded later.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_col_num_list">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_col_num_list</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_col_num_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the column in the look up file that corresponds to the correct data
:param file_path: path to the lookup csv file, includes the file name
:type file_path: str
:param col_name: the column name of the data you want to use in the lookup file, ex. “ELEV”
:type col_name: str</p>
<dl class="simple">
<dt>Returns</dt><dd><p>idx_list (list): list containing all columns in the lookup table that are called col_name</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_daily_lat_lon">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_daily_lat_lon</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_daily_lat_lon" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the latitude and longitude of the daily stations and store in a json file in the directory
Parameters</p>
<blockquote>
<div><p>file_path (str): file path to the daily csv files provided by Environment &amp; Climate Change
Canada, including the name of the file</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>The function writes a .json file to the hard drive that can be read back into the code before
running get_pcp</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_intersect_boolean_array">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_intersect_boolean_array</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ecozone_shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_intersect_boolean_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain a boolean array of where the ecozone is 0 = pixel NOT in ecozone, otherwise 1
Parameters</p>
<blockquote>
<div><p>ecozone_shapefile (str): path to ecozone shapefile, inc name
shapefile (str): path to shapefile
show (bool): show a map if you want to check it has rasterized the shapefile correctly
expand_area (bool): expand study area by 200km</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>bool_initiate (np_array): array 1/0 if pixel was inside ecozone</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_lat_lon">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_lat_lon</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_lat_lon" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the latitude and longitude of the hourly stations and write to hard drive as a json file
Parameters</p>
<blockquote>
<div><p>file_path (str): file path to the hourly csv files provided by Environment &amp; Climate Change
Canada, including the name of the file</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>The function writes a .json file to the hard drive that can be read back into the code before
running get_pcp</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_noon_temp">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_noon_temp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_noon_temp" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dictionary for noon temp data on the input date
Parameters</p>
<blockquote>
<div><p>input_date (str): input date for the date of interest, in the format: YYYY-MM-DD HH:MM
file_path (str): path to the feather files containing the hourly data from Environment &amp;
Climate Change Canada</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>temp_dictionary (dict): a dictionary of temperature values for all the active &amp; non-null stations
on the input date</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_pcp">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_pcp</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_dictionary</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_pcp" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dictionary of the precipitation data from the feather files of the daily stations
Parameters</p>
<blockquote>
<div><p>input_date (str): input date for the day of interest, in the format YYYY:MM:DD
file_path (str): file path to the daily feather files
date_dictionary (dict, loaded from .json): lookup file that has what day/month pairs each
station is active on</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>rain_dictionary (dict): dictionary containing rain amount for each station</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_pcp_dictionary_by_year">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_pcp_dictionary_by_year</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_pcp_dictionary_by_year" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a lookup file for the year_month that each daily station has data for faster
processing later –&gt; this is an input to get_pcp
Parameters</p>
<blockquote>
<div><p>file_path (str): file path to the daily csv files provided by Environment &amp; Climate Change
Canada, including the name of the file</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>The function writes a .json file to the hard drive that can be read back into the code before
running get_pcp</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_relative_humidity">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_relative_humidity</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_relative_humidity" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dictionary for rh% data on the input date
Parameters</p>
<blockquote>
<div><p>input_date (str): input date for the date of interest, in the format: YYYY-MM-DD HH:MM
file_path (str): path to the feather files containing the hourly data from Environment &amp;
Climate Change Canada</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>temp_dictionary (dict): a dictionary of relative humidity values for all the active &amp;
non-null stations on the input date</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_stations_plus_200km">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_stations_plus_200km</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_stations_plus_200km" title="Permalink to this definition">¶</a></dt>
<dd><p>Dictionary for plotting of the stations included in the analysis
Parameters</p>
<blockquote>
<div><p>latlon_dict (dict): the latitude and longitudes of the hourly stations, loaded from the
.json file
Cvar_dict (dict): dictionary of weather variable values for each station
input_date (str): the date you want to interpolate for
shapefile (str): path to the study area shapefile</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>plotting_dict (dict): contains values only for stations inside study area plus 200km</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.get_wind_speed">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">get_wind_speed</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.get_wind_speed" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dictionary for wind speed data on the input date
Parameters</p>
<blockquote>
<div><p>input_date (str): input date for the date of interest, in the format: YYYY-MM-DD HH:MM
file_path (str): path to the feather files containing the hourly data from Environment &amp;
Climate Change Canada</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>ws_dictionary (dict): a dictionary of wind speed values for all the active &amp; non-null stations
on the input date</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.is_station_in_boreal">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">is_station_in_boreal</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">days_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boreal_shapefile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.is_station_in_boreal" title="Permalink to this definition">¶</a></dt>
<dd><p>For the fire season code, we are only interested in stations within the boreal zone,
so we need to get a list of stations that are located there.
Parameters</p>
<blockquote>
<div><p>loc_dict (dict): locations of the stations
days_dict (dict): stations we are interested in, output of get_start_date_calendar_csv/end_date
boreal_shapefile (str): file path leading to the .shp file that delineates the boreal forest</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>boreal_dict (dict): dictionary, organized boreal_dict[station_name] = True</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="get_data.stack_and_average">
<code class="sig-prename descclassname"><span class="pre">get_data.</span></code><code class="sig-name descname"><span class="pre">stack_and_average</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">year1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">year2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_daily</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_hourly</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#get_data.stack_and_average" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the fire season duration for every year in between the two input years
and average them. Output the average array.</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-gpr">
<span id="fire-weather-interpolate-gpr-module"></span><h2>fire_weather_interpolate.gpr module<a class="headerlink" href="#module-gpr" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id7">
<h3>Summary<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>Spatial interpolation functions for gaussian process regression interpolation
using the scikit-learn package.</p>
<dl class="py function">
<dt id="gpr.GPR_interpolator">
<code class="sig-prename descclassname"><span class="pre">gpr.</span></code><code class="sig-name descname"><span class="pre">GPR_interpolator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restarts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">report_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_initiate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RBF'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gpr.GPR_interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Base interpolator function for gaussian process regression
Parameters</p>
<blockquote>
<div><p>latlon_dict (dict): the latitude and longitudes of the hourly or daily stations, loaded from the
.json file
Cvar_dict (dict): dictionary of weather variable values for each station
input_date (str): date to create the interpolation map for
shapefile (str): path to the study area shapefile
show (bool): whether to show the map
file_path_elev (str): file path to the elevation lookup file
idx_list (list): the index of the elevation data column in the lookup file
expand_area (bool): function will expand the study area so that more stations are taken into account (200 km)
cov (str): covariance function type, support for Rational Quadratic (but only isotropic), Matern</p>
<p>whether the spatial autocorrelation is the same in all directions it will depend on the inputs for parameters,
you need to input the parameters of the function (distribution) as a vector not a scalar… we are 3d so the vector MUST be len=3
because this corresponds to the [x,y,z] if we are using an anisotropic distribution</p>
<p>param_initiate (list, list of lists) = controls extent of the spatial autocorrelation modelled by the process
…for isotropic 1d, [1] (or if 2 parameters, [[1],[1]]), for anisotropic, will be [1,1,1] or [[1,1],[1,1],[1,1]]
restarts (int) = # times to restart to avoid local optima
report_params (bool) = if True, just outputs optimized values for kernel hyperparameters
optimizer (bool) = if False, fix parameters of covariance function</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>gpr_grid (np_array): an array of the interpolated values</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gpr.cross_validate_gpr">
<code class="sig-prename descclassname"><span class="pre">gpr.</span></code><code class="sig-name descname"><span class="pre">cross_validate_gpr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param_initiate</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov_function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gpr.cross_validate_gpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Leave-one-out cross-validation procedure for GPR
Parameters</p>
<blockquote>
<div><p>latlon_dict (dict): the latitude and longitudes of the hourly or daily stations, loaded from the
.json file
Cvar_dict (dict): dictionary of weather variable values for each station
shapefile (str): path to the study area shapefile
file_path_elev (str): file path to the elevation lookup file
elev_array (np_array): the elevation array for the study area
idx_list (list): the index of the elevation data column in the lookup file
param_initiate (list): controls extent of the spatial autocorrelation modelled by the process -
we need this so we can supervise it.</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>absolute_error_dictionary (dict): a dictionary of the absolute error at each station when it
was left out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gpr.select_block_size_gpr">
<code class="sig-prename descclassname"><span class="pre">gpr.</span></code><code class="sig-name descname"><span class="pre">select_block_size_gpr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nruns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boreal_shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov_function</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gpr.select_block_size_gpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the standard deviation of MAE values based on consective runs of the cross-valiation,
in order to select the block/cluster size
Parameters</p>
<blockquote>
<div><p>nruns (int): number of repetitions
group_type (str): whether using ‘clusters’ or ‘blocks’
loc_dict (dict): the latitude and longitudes of the daily/hourly stations,
loaded from the .json file
Cvar_dict (dict): dictionary of weather variable values for each station
idw_example_grid (numpy array): used for reference of study area grid size
shapefile (str): path to the study area shapefile
file_path_elev (str): path to the elevation lookup file
idx_list (int): position of the elevation column in the lookup file
cluster_num: three cluster numbers to test, for blocking this must be one of three:25, 16, 9
For blocking you can enter ‘None’ and it will automatically test 25, 16, 9
boreal_shapefile (str): path to shapefile with the boreal zone
cov_function (list): description of covariance function inside list</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>lowest_stdev,ave_MAE (int,float): block/cluster number w/ lowest stdev, associated
ave_MAE of all the runs</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gpr.shuffle_split_gpr">
<code class="sig-prename descclassname"><span class="pre">gpr.</span></code><code class="sig-name descname"><span class="pre">shuffle_split_gpr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gpr.shuffle_split_gpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Shuffle split cross-validation procedure for GPR
Parameters</p>
<blockquote>
<div><p>latlon_dict (dict): the latitude and longitudes of the hourly or daily stations, loaded from the
.json file
Cvar_dict (dict): dictionary of weather variable values for each station
shapefile (str): path to the study area shapefile
file_path_elev (str): file path to the elevation lookup file
elev_array (np_array): the elevation array for the study area
idx_list (list): the index of the elevation data column in the lookup file
cov_function (list): description of covariance function inside list
rep (int): number of repititions for shuffle-split</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>overall_error (float): average MAE value of all the reps</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gpr.spatial_groups_gpr">
<code class="sig-prename descclassname"><span class="pre">gpr.</span></code><code class="sig-name descname"><span class="pre">spatial_groups_gpr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocknum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfolds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dictionary_Groups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gpr.spatial_groups_gpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatially blocked bagging cross-validation procedure for IDW
Parameters</p>
<blockquote>
<div><p>idw_example_grid (numpy array): the example idw grid to base the size of the group array off of
loc_dict (dict): the latitude and longitudes of the hourly stations, loaded from the
.json file
Cvar_dict (dict): dictionary of weather variable values for each station
shapefile (str): path to the study area shapefile
file_path_elev (str): path to the elevation lookup file
idx_list (int): position of the elevation column in the lookup file
d (int): the weighting function for IDW interpolation
nfolds (int): # number of folds. For 10-fold we use 10, etc.
cov_function (list): description of covariance function inside list
expand_area (bool): expand the study area by 200km</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>error_dictionary (dict): a dictionary of the absolute error at each fold when it
was left out</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="gpr.spatial_kfold_gpr">
<code class="sig-prename descclassname"><span class="pre">gpr.</span></code><code class="sig-name descname"><span class="pre">spatial_kfold_gpr</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cov_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusterNum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocking_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#gpr.spatial_kfold_gpr" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatially blocked k-folds cross-validation procedure for rf
Parameters</p>
<blockquote>
<div><p>loc_dict (dict): the latitude and longitudes of the hourly or daily stations, loaded from the
.json file
Cvar_dict (dict): dictionary of weather variable values for each station
shapefile (str): path to the study area shapefile
file_path_elev (str): file path to the elevation lookup file
elev_array (np_array): the elevation array for the study area
idx_list (list): the index of the elevation data column in the lookup file
alpha_input(float): controls extent of the spatial autocorrelation modelled by the process (smaller = more)
cov_function (list): description of covariance function inside list
clusterNum (int): number of clusters to form
blocking_type (str): whether to block by cluster or block, either ‘cluster’ or ‘block’</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>overall_error (float): average MAE value of all the reps</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-idew">
<span id="fire-weather-interpolate-idew-module"></span><h2>fire_weather_interpolate.idew module<a class="headerlink" href="#module-idew" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id8">
<h3>Summary<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>Code for inverse distance elevation weighting with a weight of 0.8 for distance (Euclidean) and 0.2 for distance (vertical).</p>
<p class="rubric">References</p>
<p>For weights:</p>
<p>Daly, C., Gibson, W. P., Taylor, G. H., Johnson, G. L., &amp; Pasteris, P. (2002).
A knowledge-based approach to the statistical mapping of climate. Climate Research, 22(2), 99–113. <a class="reference external" href="https://doi.org/10.3354/cr022099">https://doi.org/10.3354/cr022099</a></p>
<dl class="py function">
<dt id="idew.IDEW">
<code class="sig-prename descclassname"><span class="pre">idew.</span></code><code class="sig-name descname"><span class="pre">IDEW</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idew.IDEW" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse distance elevation weighting
:param latlon_dict: the latitude and longitudes of the stations
:type latlon_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param input_date: the date you want to interpolate for
:type input_date: string
:param var_name: the name of the variable you are interpolating
:type var_name: string
:param shapefile: path to the study area shapefile, including its name
:type shapefile: string
:param show: whether you want to plot a map
:type show: bool
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param d: the weighting for IDW interpolation
:type d: int</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>ndarray</em> –</p>
<ul>
<li><p>the array of values for the interpolated surface</p></li>
</ul>
</li>
<li><p><em>list</em> –</p>
<ul>
<li><p>the bounds of the array surface, for use in other functions</p></li>
</ul>
</li>
<li><p><em>ndarray</em> –</p>
<ul>
<li><p>elevation array (for use in the random forest module</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idew.cross_validate_IDEW">
<code class="sig-prename descclassname"><span class="pre">idew.</span></code><code class="sig-name descname"><span class="pre">cross_validate_IDEW</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idew.cross_validate_IDEW" title="Permalink to this definition">¶</a></dt>
<dd><p>Leave-one-out cross-validation procedure for IDEW
:param latlon_dict: the latitude and longitudes of the stations
:type latlon_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile, including its name
:type shapefile: string
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param elev_array: array for elevation, create using IDEW interpolation (this is a trick to speed up code)
:type elev_array: ndarray
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param d: the weighting for IDW interpolation
:type d: int</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>a dictionary of the absolute error at each station when it was left out</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idew.select_block_size_IDEW">
<code class="sig-prename descclassname"><span class="pre">idew.</span></code><code class="sig-name descname"><span class="pre">select_block_size_IDEW</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nruns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idew.select_block_size_IDEW" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the standard deviation of MAE values based on consective runs of the cross-valiation, in order to select the block/cluster size
:param nruns: number of repetitions
:type nruns: int
:param group_type: whether using ‘clusters’ or ‘blocks’
:type group_type: string
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param shapefile: path to the study area shapefile
:type shapefile: string
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param elev_array: array for elevation, create using IDEW interpolation (this is a trick to speed up code)
:type elev_array: ndarray
:param d: the weighting for IDW interpolation
:type d: int</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>int</em> –</p>
<ul>
<li><p>block/cluster number with lowest stdev</p></li>
</ul>
</li>
<li><p><em>float</em> –</p>
<ul>
<li><p>average MAE of all the runs for that cluster/block number</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idew.shuffle_split_IDEW">
<code class="sig-prename descclassname"><span class="pre">idew.</span></code><code class="sig-name descname"><span class="pre">shuffle_split_IDEW</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idew.shuffle_split_IDEW" title="Permalink to this definition">¶</a></dt>
<dd><p>Shuffle-split cross-validation with 50/50 training test split
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param elev_array: array for elevation, create using IDEW interpolation (this is a trick to speed up code)
:type elev_array: ndarray
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param d: the weighting for IDW interpolation
:type d: int
:param rep: number of replications
:type rep: int</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>MAE estimate for entire surface (average of replications)</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idew.spatial_groups_IDEW">
<code class="sig-prename descclassname"><span class="pre">idew.</span></code><code class="sig-name descname"><span class="pre">spatial_groups_IDEW</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocknum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfolds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dictionary_Groups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idew.spatial_groups_IDEW" title="Permalink to this definition">¶</a></dt>
<dd><p>Stratified shuffle-split cross-validation procedure
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param d: the weighting for IDW interpolation
:type d: int
:param blocknum: number of blocks/clusters
:type blocknum: int
:param nfolds: number of folds to create (essentially repetitions)
:type nfolds: int
:param replacement: whether or not to use replacement between folds, should usually be true
:type replacement: bool
:param dictionary_Groups: dictionary of what groups (clusters) the stations belong to
:type dictionary_Groups: dictionary
:param elev_array: array for elevation, create using IDEW interpolation (this is a trick to speed up code)
:type elev_array: ndarray</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>a dictionary of the absolute error at each fold when it was left out</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idew.spatial_kfold_IDEW">
<code class="sig-prename descclassname"><span class="pre">idew.</span></code><code class="sig-name descname"><span class="pre">spatial_kfold_IDEW</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocking_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idew.spatial_kfold_IDEW" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatially blocked k-folds cross-validation procedure for IDEW
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param d: the weighting for IDW interpolation
:type d: int
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param elev_array: array for elevation, create using IDEW interpolation (this is a trick to speed up code)
:type elev_array: ndarray
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param block_num: number of blocks/clusters
:type block_num: int
:param blocking_type: whether to use clusters or blocks
:type blocking_type: string</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>float</em> –</p>
<ul>
<li><p>MAE estimate for entire surface</p></li>
</ul>
</li>
<li><p><em>int</em> –</p>
<ul>
<li><p>Return the block number just so we can later write it into the file to keep track</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-idw">
<span id="fire-weather-interpolate-idw-module"></span><h2>fire_weather_interpolate.idw module<a class="headerlink" href="#module-idw" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id9">
<h3>Summary<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<p>Code for interpolating weather data using inverse distance weighting interpolation.</p>
<p class="rubric">References</p>
<p>Code for IDW modified from <a class="reference external" href="https://stackoverflow.com/questions/3104781/inverse-distance-weighted-idw-interpolation-with-python?rq=1">https://stackoverflow.com/questions/3104781/inverse-distance-weighted-idw-interpolation-with-python?rq=1</a> (answer by Joe Kington)
[1] Kington, J. “Inverse Distance Weighted (IDW) Interpolation with Python” <a class="reference external" href="https://stackoverflow.com/questions/3104781/inverse-distance-weighted-idw-interpolation-with-python?rq=1">https://stackoverflow.com/questions/3104781/inverse-distance-weighted-idw-interpolation-with-python?rq=1</a>. Jun 2010.
Last accessed: 2020-12-26.</p>
<dl class="py function">
<dt id="idw.IDW">
<code class="sig-prename descclassname"><span class="pre">idw.</span></code><code class="sig-name descname"><span class="pre">IDW</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idw.IDW" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse distance weighting interpolation
:param latlon_dict: the latitude and longitudes of the stations
:type latlon_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param input_date: the date you want to interpolate for
:type input_date: string
:param var_name: the name of the variable you are interpolating
:type var_name: string
:param shapefile: path to the study area shapefile, including its name
:type shapefile: string
:param show: whether you want to plot a map
:type show: bool
:param d: the weighting for IDW interpolation
:type d: int
:param expand_area: function will expand the study area so that more stations are taken into account (200 km)
:type expand_area: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>ndarray</em> –</p>
<ul>
<li><p>the array of values for the interpolated surface</p></li>
</ul>
</li>
<li><p><em>list</em> –</p>
<ul>
<li><p>the bounds of the array surface, for use in other functions</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idw.cross_validate_IDW">
<code class="sig-prename descclassname"><span class="pre">idw.</span></code><code class="sig-name descname"><span class="pre">cross_validate_IDW</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_to_plot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idw.cross_validate_IDW" title="Permalink to this definition">¶</a></dt>
<dd><p>Leave-one-out cross-validation procedure for IDW
:param latlon_dict: the latitude and longitudes of the stations
:type latlon_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile, including its name
:type shapefile: string
:param d: the weighting for IDW interpolation
:type d: int
:param pass_to_plot: whether you will be plotting the error and need a version without absolute value error (i.e. fire season days)
:type pass_to_plot: bool
:param expand_area: function will expand the study area so that more stations are taken into account (200 km)
:type expand_area: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>dictionary</em> –</p>
<ul>
<li><p>a dictionary of the absolute error at each station when it was left out</p></li>
</ul>
</li>
<li><p><em>dictionary</em> –</p>
<ul>
<li><p>if pass_to_plot = True, returns a dictionary without the absolute value of the error, for example for plotting fire season error</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idw.select_block_size_IDW">
<code class="sig-prename descclassname"><span class="pre">idw.</span></code><code class="sig-name descname"><span class="pre">select_block_size_IDW</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nruns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boreal_shapefile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idw.select_block_size_IDW" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the standard deviation of MAE values based on consective runs of the cross-valiation, in order to select the block/cluster size
:param nruns: number of repetitions
:type nruns: int
:param group_type: whether using ‘clusters’ or ‘blocks’
:type group_type: string
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param shapefile: path to the study area shapefile
:type shapefile: string
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param d: the weighting for IDW interpolation
:type d: int
:param cluster_num1-3: three cluster numbers to test, for blocking this must be one of three:25, 16, 9</p>
<blockquote>
<div><p>you can enter ‘None’ and it will automatically test 25, 16, 9</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expand_area</strong> (<em>bool</em>) – expand area by 200km</p></li>
<li><p><strong>boreal_shapefile</strong> (<em>string</em>) – path to shapefile with the boreal zone</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>int</em> –</p>
<ul>
<li><p>block/cluster number with lowest stdev</p></li>
</ul>
</li>
<li><p><em>float</em> –</p>
<ul>
<li><p>average MAE of all the runs for that cluster/block number</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idw.shuffle_split">
<code class="sig-prename descclassname"><span class="pre">idw.</span></code><code class="sig-name descname"><span class="pre">shuffle_split</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idw.shuffle_split" title="Permalink to this definition">¶</a></dt>
<dd><p>Shuffle-split cross-validation with 50/50 training test split
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param d: the weighting for IDW interpolation
:type d: int
:param rep: number of replications
:type rep: int
:param show: if you want to show a map of the clusters
:type show: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>MAE estimate for entire surface (average of replications)</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idw.spatial_groups_IDW">
<code class="sig-prename descclassname"><span class="pre">idw.</span></code><code class="sig-name descname"><span class="pre">spatial_groups_IDW</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocknum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfolds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dictionary_Groups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idw.spatial_groups_IDW" title="Permalink to this definition">¶</a></dt>
<dd><p>Stratified shuffle-split cross-validation procedure
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param d: the weighting for IDW interpolation
:type d: int
:param blocknum: number of blocks/clusters
:type blocknum: int
:param nfolds: number of folds to create (essentially repetitions)
:type nfolds: int
:param replacement: whether or not to use replacement between folds, should usually be true
:type replacement: bool
:param dictionary_Groups: dictionary of what groups (clusters) the stations belong to
:type dictionary_Groups: dictionary
:param expand_area: function will expand the study area so that more stations are taken into account (200 km)
:type expand_area: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>a dictionary of the absolute error at each fold when it was left out</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="idw.spatial_kfold_idw">
<code class="sig-prename descclassname"><span class="pre">idw.</span></code><code class="sig-name descname"><span class="pre">spatial_kfold_idw</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocking_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_error</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#idw.spatial_kfold_idw" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatially blocked k-fold cross-validation procedure for IDW
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param d: the weighting for IDW interpolation
:type d: int
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param block_num: number of blocks/clusters
:type block_num: int
:param blocking_type: whether to use clusters or blocks
:type blocking_type: string
:param return_error: whether or not to return the error dictionary
:type return_error: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>float</em> –</p>
<ul>
<li><p>MAE estimate for entire surface</p></li>
</ul>
</li>
<li><p><em>int</em> –</p>
<ul>
<li><p>Return the block number just so we can later write it into the file to keep track</p></li>
</ul>
</li>
<li><p><em>dictionary</em> –</p>
<ul>
<li><p>if return_error = True, a dictionary of the absolute error at each fold when it was left out</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-make_blocks">
<span id="fire-weather-interpolate-make-blocks-module"></span><h2>fire_weather_interpolate.make_blocks module<a class="headerlink" href="#module-make_blocks" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id10">
<h3>Summary<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>Code for creating spatial blocks for cross-validation.</p>
<dl class="py function">
<dt id="make_blocks.make_block">
<code class="sig-prename descclassname"><span class="pre">make_blocks.</span></code><code class="sig-name descname"><span class="pre">make_block</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idw_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocknum</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#make_blocks.make_block" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide the study area into blocks
Parameters</p>
<blockquote>
<div><p>idw_grid (numpy array): the example idw grid to base the size of the group array off of
blocknum (int): number of blocks to create, either 4,9,16,25</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>blocks (numpy array): an array with the block value contained in each pixel</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="make_blocks.sorting_stations">
<code class="sig-prename descclassname"><span class="pre">make_blocks.</span></code><code class="sig-name descname"><span class="pre">sorting_stations</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#make_blocks.sorting_stations" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the stations in each block and create a reference dictionary for this information
Parameters</p>
<blockquote>
<div><p>blocks (numpy array): output of the make_block function
shapefile (str): path to shapefile of study area
loc_dict (dict): dictionary with weather station locations
Cvar_dict (dict): the dictionary keyed by station with the weather data inside</p>
</div></blockquote>
<dl class="simple">
<dt>Returns</dt><dd><p>groups (dict): dictionary of the block for each station</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-rf">
<span id="fire-weather-interpolate-rf-module"></span><h2>fire_weather_interpolate.rf module<a class="headerlink" href="#module-rf" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id11">
<h3>Summary<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>Spatial interpolation functions for random forest interpolation
using the scikit-learn package.</p>
<dl class="py function">
<dt id="rf.cross_validate_rf">
<code class="sig-prename descclassname"><span class="pre">rf.</span></code><code class="sig-name descname"><span class="pre">cross_validate_rf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_to_plot</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rf.cross_validate_rf" title="Permalink to this definition">¶</a></dt>
<dd><p>Leave-one-out cross-validation procedure for RF
:param latlon_dict: the latitude and longitudes of the stations
:type latlon_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile, including its name
:type shapefile: string
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param elev_array: array for elevation, create using IDEW interpolation (this is a trick to speed up code)
:type elev_array: ndarray
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param pass_to_plot: whether you will be plotting the error and need a version without absolute value error (i.e. fire season days)
:type pass_to_plot: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>dictionary</em> –</p>
<ul>
<li><p>a dictionary of the absolute error at each station when it was left out</p></li>
</ul>
</li>
<li><p><em>dictionary</em> –</p>
<ul>
<li><p>if pass_to_plot = True, returns a dictionary without the absolute value of the error, for example for plotting fire season error</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="rf.random_forest_interpolator">
<code class="sig-prename descclassname"><span class="pre">rf.</span></code><code class="sig-name descname"><span class="pre">random_forest_interpolator</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rf.random_forest_interpolator" title="Permalink to this definition">¶</a></dt>
<dd><p>Random forest interpolation
:param latlon_dict: the latitude and longitudes of the stations
:type latlon_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param input_date: the date you want to interpolate for
:type input_date: string
:param var_name: the name of the variable you are interpolating
:type var_name: string
:param shapefile: path to the study area shapefile, including its name
:type shapefile: string
:param show: whether you want to plot a map
:type show: bool
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param expand_area: function will expand the study area so that more stations are taken into account (200 km)
:type expand_area: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>ndarray</em> –</p>
<ul>
<li><p>the array of values for the interpolated surface</p></li>
</ul>
</li>
<li><p><em>list</em> –</p>
<ul>
<li><p>the bounds of the array surface, for use in other functions</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="rf.select_block_size_rf">
<code class="sig-prename descclassname"><span class="pre">rf.</span></code><code class="sig-name descname"><span class="pre">select_block_size_rf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nruns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boreal_shapefile</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rf.select_block_size_rf" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the standard deviation of MAE values based on consective runs of the cross-valiation,
in order to select the block/cluster size
:param nruns: number of repetitions
:type nruns: int
:param group_type: whether using ‘clusters’ or ‘blocks’
:type group_type: string
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param shapefile: path to the study area shapefile
:type shapefile: string
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param cluster_num1-3: three cluster numbers to test, for blocking this must be one of three:25, 16, 9</p>
<blockquote>
<div><p>you can enter ‘None’ and it will automatically test 25, 16, 9</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expand_area</strong> (<em>bool</em>) – expand area by 200km</p></li>
<li><p><strong>boreal_shapefile</strong> (<em>string</em>) – path to shapefile with the boreal zone</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>int</em> –</p>
<ul>
<li><p>block/cluster number with lowest stdev</p></li>
</ul>
</li>
<li><p><em>float</em> –</p>
<ul>
<li><p>average MAE of all the runs for that cluster/block number</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="rf.shuffle_split_rf">
<code class="sig-prename descclassname"><span class="pre">rf.</span></code><code class="sig-name descname"><span class="pre">shuffle_split_rf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rep</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rf.shuffle_split_rf" title="Permalink to this definition">¶</a></dt>
<dd><p>Shuffle-split cross-validation with 50/50 training test split
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile:     path to the study area shapefile</p>
<blockquote>
<div><dl class="simple">
<dt>file_path_elev<span class="classifier">string</span></dt><dd><p>path to the elevation lookup file</p>
</dd>
<dt>elev_array<span class="classifier">ndarray</span></dt><dd><p>array for elevation, create using IDEW interpolation (this is a trick to speed up code)</p>
</dd>
<dt>idx_list<span class="classifier">int</span></dt><dd><p>position of the elevation column in the lookup file</p>
</dd>
</dl>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>rep</strong> (<em>int</em>) – number of replications</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p>MAE estimate for entire surface (average of replications)</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="rf.spatial_groups_rf">
<code class="sig-prename descclassname"><span class="pre">rf.</span></code><code class="sig-name descname"><span class="pre">spatial_groups_rf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocknum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfolds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dictionary_Groups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rf.spatial_groups_rf" title="Permalink to this definition">¶</a></dt>
<dd><p>Stratified shuffle-split cross-validation procedure
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param d: the weighting for IDW interpolation
:type d: int
:param blocknum: number of blocks/clusters
:type blocknum: int
:param nfolds: number of folds to create (essentially repetitions)
:type nfolds: int
:param replacement: whether or not to use replacement between folds, should usually be true
:type replacement: bool
:param dictionary_Groups: dictionary of what groups (clusters) the stations belong to
:type dictionary_Groups: dictionary
:param expand_area: function will expand the study area so that more stations are taken into account (200 km)
:type expand_area: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>a dictionary of the absolute error at each fold when it was left out</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="rf.spatial_kfold_rf">
<code class="sig-prename descclassname"><span class="pre">rf.</span></code><code class="sig-name descname"><span class="pre">spatial_kfold_rf</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elev_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocking_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_error</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#rf.spatial_kfold_rf" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatially blocked k-fold cross-validation procedure for RF
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param d: the weighting for IDW interpolation
:type d: int
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param elev_array: array for elevation, create using IDEW interpolation (this is a trick to speed up code)
:type elev_array: ndarray
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param block_num: number of blocks/clusters
:type block_num: int
:param blocking_type: whether to use clusters or blocks
:type blocking_type: string
:param return_error: whether or not to return the error dictionary
:type return_error: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>float</em> –</p>
<ul>
<li><p>MAE estimate for entire surface</p></li>
</ul>
</li>
<li><p><em>int</em> –</p>
<ul>
<li><p>Return the block number just so we can later write it into the file to keep track</p></li>
</ul>
</li>
<li><p><em>dictionary</em> –</p>
<ul>
<li><p>if return_error = True, a dictionary of the absolute error at each fold when it was left out</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
<div class="section" id="module-tps">
<span id="fire-weather-interpolate-tps-module"></span><h2>fire_weather_interpolate.tps module<a class="headerlink" href="#module-tps" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id12">
<h3>Summary<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>Interpolation functions for thin plate splines using the radial basis function
from SciPy.</p>
<p class="rubric">References</p>
<p>Flannigan, M. D., &amp; Wotton, B. M. (1989). A study of interpolation methods for forest fire danger rating in Canada.
Canadian Journal of Forest Research, 19(8), 1059–1066. <a class="reference external" href="https://doi.org/10.1139/x89-161">https://doi.org/10.1139/x89-161</a></p>
<dl class="py function">
<dt id="tps.TPS">
<code class="sig-prename descclassname"><span class="pre">tps.</span></code><code class="sig-name descname"><span class="pre">TPS</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile_masking</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tps.TPS" title="Permalink to this definition">¶</a></dt>
<dd><p>Thin plate splines interpolation implemented using the interpolate radial basis function from
SciPy
:param latlon_dict: the latitude and longitudes of the stations
:type latlon_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param input_date: the date you want to interpolate for
:type input_date: string
:param var_name: the name of the variable you are interpolating
:type var_name: string
:param shapefile: path to the study area shapefile, including its name
:type shapefile: string
:param show: whether you want to plot a map
:type show: bool
:param phi: smoothing parameter for the thin plate spline, if 0 no smoothing
:type phi: float
:param expand_area: function will expand the study area so that more stations are taken into account (200 km)
:type expand_area: bool
:param calc_phi: whether the function will automatically calculate phi (use if expand_area == True); if calc_phi == True, the function will ignore the input value for phi
:type calc_phi: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>ndarray</em> –</p>
<ul>
<li><p>the array of values for the interpolated surface</p></li>
</ul>
</li>
<li><p><em>list</em> –</p>
<ul>
<li><p>the bounds of the array surface, for use in other functions</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tps.cross_validate_tps">
<code class="sig-prename descclassname"><span class="pre">tps.</span></code><code class="sig-name descname"><span class="pre">cross_validate_tps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_to_plot</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tps.cross_validate_tps" title="Permalink to this definition">¶</a></dt>
<dd><p>Leave-one-out cross-validation for thin plate splines
:param latlon_dict: the latitude and longitudes of the stations
:type latlon_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile, including its name
:type shapefile: string
:param phi: smoothing parameter for the thin plate spline, if 0 no smoothing
:type phi: float
:param pass_to_plot: whether you will be plotting the error and need a version without absolute value error (i.e. fire season days)
:type pass_to_plot: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>dictionary</em> –</p>
<ul>
<li><p>a dictionary of the absolute error at each station when it was left out</p></li>
</ul>
</li>
<li><p><em>dictionary</em> –</p>
<ul>
<li><p>if pass_to_plot = True, returns a dictionary without the absolute value of the error, for example for plotting fire season error</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tps.select_block_size_tps">
<code class="sig-prename descclassname"><span class="pre">tps.</span></code><code class="sig-name descname"><span class="pre">select_block_size_tps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nruns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_num3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boreal_shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tps.select_block_size_tps" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the standard deviation of MAE values based on consective runs of the cross-valiation,
in order to select the block/cluster size
:param nruns: number of repetitions
:type nruns: int
:param group_type: whether using ‘clusters’ or ‘blocks’
:type group_type: string
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param shapefile: path to the study area shapefile
:type shapefile: string
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param phi: smoothing parameter for the thin plate spline, if 0 no smoothing
:type phi: float
:param cluster_num1-3: three cluster numbers to test, for blocking this must be one of three:25, 16, 9</p>
<blockquote>
<div><p>you can enter ‘None’ and it will automatically test 25, 16, 9</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>expand_area</strong> (<em>bool</em>) – expand area by 200km</p></li>
<li><p><strong>boreal_shapefile</strong> (<em>string</em>) – path to shapefile with the boreal zone</p></li>
<li><p><strong>calc_phi</strong> (<em>bool</em>) – whether to calculate phi in the function, if True, phi can = None</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>int</em> –</p>
<ul>
<li><p>block/cluster number with lowest stdev</p></li>
</ul>
</li>
<li><p><em>float</em> –</p>
<ul>
<li><p>average MAE of all the runs for that cluster/block number</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tps.shuffle_split_tps">
<code class="sig-prename descclassname"><span class="pre">tps.</span></code><code class="sig-name descname"><span class="pre">shuffle_split_tps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">latlon_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tps.shuffle_split_tps" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Shuffle-split cross-validation for thin plate splines</dt><dd><blockquote>
<div><dl class="simple">
<dt>loc_dict<span class="classifier">dictionary</span></dt><dd><p>the latitude and longitudes of the daily/hourly stations</p>
</dd>
<dt>Cvar_dict<span class="classifier">dictionary</span></dt><dd><p>dictionary of weather variable values for each station</p>
</dd>
<dt>shapefile<span class="classifier">string</span></dt><dd><p>path to the study area shapefile</p>
</dd>
<dt>rep<span class="classifier">int</span></dt><dd><p>number of replications</p>
</dd>
<dt>phi<span class="classifier">float</span></dt><dd><p>smoothing parameter for the thin plate spline, if 0 no smoothing, default is None (it is calculated)</p>
</dd>
<dt>calc_phi<span class="classifier">bool</span></dt><dd><p>whether to calculate phi in the function, if True, phi can = None</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>MAE estimate for entire surface (average of replications)</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tps.spatial_groups_tps">
<code class="sig-prename descclassname"><span class="pre">tps.</span></code><code class="sig-name descname"><span class="pre">spatial_groups_tps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocknum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nfolds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dictionary_Groups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expand_area</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tps.spatial_groups_tps" title="Permalink to this definition">¶</a></dt>
<dd><p>Stratified shuffle-split cross-validation procedure
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param phi: smoothing parameter for the thin plate spline, if 0 no smoothing
:type phi: float
:param blocknum: number of blocks/clusters
:type blocknum: int
:param nfolds: number of folds to create (essentially repetitions)
:type nfolds: int
:param replacement: whether or not to use replacement between folds, should usually be true
:type replacement: bool
:param dictionary_Groups: dictionary of what groups (clusters) the stations belong to
:type dictionary_Groups: dictionary
:param expand_area: function will expand the study area so that more stations are taken into account (200 km)
:type expand_area: bool
:param calc_phi: whether to calculate phi in the function, if True, phi can = None
:type calc_phi: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p>a dictionary of the absolute error at each fold when it was left out</p></li>
</ul>
</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dictionary</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt id="tps.spatial_kfold_tps">
<code class="sig-prename descclassname"><span class="pre">tps.</span></code><code class="sig-name descname"><span class="pre">spatial_kfold_tps</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">idw_example_grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Cvar_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shapefile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_path_elev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_num</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocking_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_error</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">calc_phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tps.spatial_kfold_tps" title="Permalink to this definition">¶</a></dt>
<dd><p>Spatially blocked k-folds cross-validation procedure for thin plate splines
:param idw_example_grid: used for reference of study area grid size
:type idw_example_grid: ndarray
:param loc_dict: the latitude and longitudes of the daily/hourly stations
:type loc_dict: dictionary
:param Cvar_dict: dictionary of weather variable values for each station
:type Cvar_dict: dictionary
:param shapefile: path to the study area shapefile
:type shapefile: string
:param phi: smoothing parameter for the thin plate spline, if 0 no smoothing
:type phi: float
:param file_path_elev: path to the elevation lookup file
:type file_path_elev: string
:param idx_list: position of the elevation column in the lookup file
:type idx_list: int
:param block_num: number of blocks/clusters
:type block_num: int
:param blocking_type: whether to use clusters or blocks
:type blocking_type: string
:param return_error: whether or not to return the error dictionary
:type return_error: bool
:param calc_phi: whether to calculate phi in the function, if True, phi can = None
:type calc_phi: bool</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><em>float</em> –</p>
<ul>
<li><p>MAE estimate for entire surface</p></li>
</ul>
</li>
<li><p><em>int</em> –</p>
<ul>
<li><p>Return the block number just so we can later write it into the file to keep track</p></li>
</ul>
</li>
<li><p><em>dictionary</em> –</p>
<ul>
<li><p>if return_error = True, a dictionary of the absolute error at each fold when it was left out</p></li>
</ul>
</li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">fire_weather_interpolate package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-Eval">fire_weather_interpolate.Eval module</a><ul>
<li><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-auto_select">fire_weather_interpolate.auto_select module</a><ul>
<li><a class="reference internal" href="#id1">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-cluster_3d">fire_weather_interpolate.cluster_3d module</a><ul>
<li><a class="reference internal" href="#id2">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-fwi">fire_weather_interpolate.fwi module</a><ul>
<li><a class="reference internal" href="#id3">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-get_data">fire_weather_interpolate.get_data module</a><ul>
<li><a class="reference internal" href="#id4">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-gpr">fire_weather_interpolate.gpr module</a><ul>
<li><a class="reference internal" href="#id7">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-idew">fire_weather_interpolate.idew module</a><ul>
<li><a class="reference internal" href="#id8">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-idw">fire_weather_interpolate.idw module</a><ul>
<li><a class="reference internal" href="#id9">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-make_blocks">fire_weather_interpolate.make_blocks module</a><ul>
<li><a class="reference internal" href="#id10">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-rf">fire_weather_interpolate.rf module</a><ul>
<li><a class="reference internal" href="#id11">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-tps">fire_weather_interpolate.tps module</a><ul>
<li><a class="reference internal" href="#id12">Summary</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/fire_weather_interpolate.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Fire Weather Interpolate 0.1.1 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">fire_weather_interpolate package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Clara Risk, Patrick James.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.5.4.
    </div>
  </body>
</html>